import {
    tracked
} from "@glimmer/tracking";
import {
    action
} from "@ember/object";
import {
    cancel
} from "@ember/runloop";
import {
    makeArray
} from "discourse-common/lib/helpers";
import discourseLater from "discourse-common/lib/later";
import {
    bind
} from "discourse-common/utils/decorators";
const TOUCH_OPTIONS = {
    passive: true,
    capture: true
};

function cancelEvent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
}
export default class FloatKitInstance {
    static {
        dt7948.g(this.prototype, "id", [tracked], function() {
            return null;
        });
    }#
    id = (dt7948.i(this, "id"), void 0);
    async show() {
        await this.options.onShow ? .();
    }
    static {
        dt7948.n(this.prototype, "show", [action]);
    }
    async close() {
        await this.options.onClose ? .();
    }
    static {
        dt7948.n(this.prototype, "close", [action]);
    }
    async onFocus(event) {
        await this.onTrigger(event);
    }
    static {
        dt7948.n(this.prototype, "onFocus", [action]);
    }
    async onBlur(event) {
        await this.onTrigger(event);
    }
    static {
        dt7948.n(this.prototype, "onBlur", [action]);
    }
    async onFocusIn(event) {
        await this.onTrigger(event);
    }
    static {
        dt7948.n(this.prototype, "onFocusIn", [action]);
    }
    async onFocusOut(event) {
        await this.onTrigger(event);
    }
    static {
        dt7948.n(this.prototype, "onFocusOut", [action]);
    }
    trapPointerDown(event) {
        // this is done to avoid trigger on click outside when you click on your own trigger
        // given trigger and content are not in the same div, we can't just check if target is
        // inside the menu
        event.stopPropagation();
    }
    static {
        dt7948.n(this.prototype, "trapPointerDown", [action]);
    }
    onTouchStart(event) {
        if (event.touches.length > 1) {
            this.onTouchCancel();
            return;
        }
        event.stopPropagation();
        this.trigger.addEventListener("touchmove", this.onTouchCancel, TOUCH_OPTIONS);
        this.trigger.addEventListener("touchcancel", this.onTouchCancel, TOUCH_OPTIONS);
        this.trigger.addEventListener("touchend", this.onTouchCancel, TOUCH_OPTIONS);
        this.touchTimeout = discourseLater(() => {
            if (this.isDestroying || this.isDestroyed) {
                return;
            }
            this.trigger.addEventListener("touchend", cancelEvent, {
                once: true,
                capture: true
            });
            this.onTrigger(event);
        }, 500);
    }
    static {
        dt7948.n(this.prototype, "onTouchStart", [action]);
    }
    onTouchCancel() {
        cancel(this.touchTimeout);
        this.trigger.removeEventListener("touchmove", this.onTouchCancel);
        this.trigger.removeEventListener("touchend", this.onTouchCancel);
        this.trigger.removeEventListener("touchcancel", this.onTouchCancel);
    }
    static {
        dt7948.n(this.prototype, "onTouchCancel", [bind]);
    }
    tearDownListeners() {
        if (typeof this.trigger.addEventListener === "function") {
            this.trigger.removeEventListener("pointerdown", this.trapPointerDown);
        }
        if (!this.options ? .listeners) {
            return;
        }
        makeArray(this.triggers).filter(Boolean).forEach(trigger => {
            switch (trigger) {
                case "hold":
                    this.trigger.addEventListener("touchstart", this.onTouchStart);
                    break;
                case "focus":
                    this.trigger.removeEventListener("focus", this.onFocus);
                    this.trigger.removeEventListener("blur", this.onBlur);
                    break;
                case "focusin":
                    this.trigger.removeEventListener("focusin", this.onFocusIn);
                    this.trigger.removeEventListener("focusout", this.onFocusOut);
                    break;
                case "hover":
                    this.trigger.removeEventListener("mousemove", this.onMouseMove);
                    if (!this.options.interactive) {
                        this.trigger.removeEventListener("mouseleave", this.onMouseLeave);
                    }
                    break;
                case "click":
                    this.trigger.removeEventListener("click", this.onClick);
                    break;
            }
        });
        cancel(this.touchTimeout);
    }
    setupListeners() {
        if (typeof this.trigger.addEventListener === "function") {
            this.trigger.addEventListener("pointerdown", this.trapPointerDown);
        }
        if (!this.options ? .listeners) {
            return;
        }
        makeArray(this.triggers).filter(Boolean).forEach(trigger => {
            switch (trigger) {
                case "hold":
                    this.trigger.addEventListener("touchstart", this.onTouchStart, TOUCH_OPTIONS);
                    break;
                case "focus":
                    this.trigger.addEventListener("focus", this.onFocus, {
                        passive: true
                    });
                    this.trigger.addEventListener("blur", this.onBlur, {
                        passive: true
                    });
                    break;
                case "focusin":
                    this.trigger.addEventListener("focusin", this.onFocusIn, {
                        passive: true
                    });
                    this.trigger.addEventListener("focusout", this.onFocusOut, {
                        passive: true
                    });
                    break;
                case "hover":
                    this.trigger.addEventListener("mousemove", this.onMouseMove, {
                        passive: true
                    });
                    if (!this.options.interactive) {
                        this.trigger.addEventListener("mouseleave", this.onMouseLeave, {
                            passive: true
                        });
                    }
                    break;
                case "click":
                    this.trigger.addEventListener("click", this.onClick, {
                        passive: true
                    });
                    break;
            }
        });
    }
    get triggers() {
        return this.options.triggers ? ? ["click"];
    }
    get untriggers() {
        return this.options.untriggers ? ? ["click"];
    }
}