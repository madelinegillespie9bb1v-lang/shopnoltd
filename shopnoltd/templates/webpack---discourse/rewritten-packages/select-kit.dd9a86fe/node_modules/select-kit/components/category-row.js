import Component from "@glimmer/component";
import {
    cached
} from "@glimmer/tracking";
import {
    on
} from "@ember/modifier";
import {
    action
} from "@ember/object";
import {
    guidFor
} from "@ember/object/internals";
import {
    service
} from "@ember/service";
import {
    htmlSafe
} from "@ember/template";
import {
    isEmpty,
    isNone
} from "@ember/utils";
import {
    categoryBadgeHTML
} from "discourse/helpers/category-link";
import concatClass from "discourse/helpers/concat-class";
import dirSpan from "discourse/helpers/dir-span";
import Category from "discourse/models/category";
import {
    precompileTemplate
} from "@ember/template-compilation";
import {
    setComponentTemplate
} from "@ember/component";
export default class CategoryRow extends Component {
    static {
        dt7948.g(this.prototype, "site", [service]);
    }#
    site = (dt7948.i(this, "site"), void 0);
    static {
        dt7948.g(this.prototype, "siteSettings", [service]);
    }#
    siteSettings = (dt7948.i(this, "siteSettings"), void 0);
    get isNone() {
        return this.rowValue === this.args.selectKit ? .noneItem;
    }
    get highlightedValue() {
        return this.args.selectKit.get("highlighted.id");
    }
    get isHighlighted() {
        return this.rowValue === this.highlightedValue;
    }
    get isSelected() {
        return this.rowValue === this.args.value;
    }
    get hideParentCategory() {
        return this.args.selectKit.options.hideParentCategory;
    }
    get categoryLink() {
        return this.args.selectKit.options.categoryLink;
    }
    get countSubcategories() {
        return this.args.selectKit.options.countSubcategories;
    }
    get allowUncategorizedTopics() {
        return this.siteSettings.hideParentCategory;
    }
    get allowUncategorized() {
        return this.args.selectKit.options.allowUncategorized;
    }
    get rowName() {
        return this.args.item ? .name;
    }
    get rowValue() {
        return this.args.item ? .id;
    }
    get guid() {
        return guidFor(this.args.item);
    }
    get label() {
        return this.args.item ? .name || this.args.item ? .label;
    }
    get displayCategoryDescription() {
        const option1 = this.args.selectKit.options.displayCategoryDescription;
        if (isNone(option1)) {
            return true;
        }
        return option1;
    }
    get title() {
        if (this.category) {
            return this.categoryName;
        }
    }
    get categoryName() {
        return this.category.displayName;
    }
    get categoryDescriptionText() {
        return this.category.descriptionText;
    }
    get category() {
        if (isEmpty(this.rowValue)) {
            const uncategorized1 = Category.findUncategorized();
            if (uncategorized1 && uncategorized1.name === this.rowName) {
                return uncategorized1;
            }
        } else {
            return Category.findById(parseInt(this.rowValue, 10));
        }
    }
    static {
        dt7948.n(this.prototype, "category", [cached]);
    }
    get badgeForCategory() {
        return htmlSafe(categoryBadgeHTML(this.category, {
            link: this.categoryLink,
            allowUncategorized: this.allowUncategorizedTopics || this.allowUncategorized,
            hideParent: !!this.parentCategory,
            topicCount: this.topicCount,
            subcategoryCount: this.args.item ? .category ? this.category.subcategory_count : 0
        }));
    }
    static {
        dt7948.n(this.prototype, "badgeForCategory", [cached]);
    }
    get badgeForParentCategory() {
        return htmlSafe(categoryBadgeHTML(this.parentCategory, {
            link: this.categoryLink,
            allowUncategorized: this.allowUncategorizedTopics || this.allowUncategorized,
            recursive: true
        }));
    }
    static {
        dt7948.n(this.prototype, "badgeForParentCategory", [cached]);
    }
    get parentCategory() {
        return Category.findById(this.parentCategoryId);
    }
    get hasParentCategory() {
        return this.parentCategoryId;
    }
    get parentCategoryId() {
        return this.category ? .parent_category_id;
    }
    get categoryTotalTopicCount() {
        return this.category ? .totalTopicCount;
    }
    get categoryTopicCount() {
        return this.category ? .topic_count;
    }
    get topicCount() {
        return this.countSubcategories ? this.categoryTotalTopicCount : this.categoryTopicCount;
    }
    get shouldDisplayDescription() {
        return this.displayCategoryDescription && this.categoryDescriptionText && this.categoryDescriptionText !== "null";
    }
    get descriptionText() {
        if (this.categoryDescriptionText) {
            return this._formatDescription(this.categoryDescriptionText);
        }
    }
    static {
        dt7948.n(this.prototype, "descriptionText", [cached]);
    }
    handleMouseEnter() {
        if (this.site.mobileView) {
            return;
        }
        if (!this.isDestroying || !this.isDestroyed) {
            this.args.selectKit.onHover(this.rowValue, this.args.item);
        }
        return false;
    }
    static {
        dt7948.n(this.prototype, "handleMouseEnter", [action]);
    }
    handleClick(event1) {
        event1.preventDefault();
        event1.stopPropagation();
        this.args.selectKit.select(this.rowValue, this.args.item);
        return false;
    }
    static {
        dt7948.n(this.prototype, "handleClick", [action]);
    }
    handleMouseDown(event1) {
        if (this.args.selectKit.options.preventHeaderFocus) {
            event1.preventDefault();
        }
    }
    static {
        dt7948.n(this.prototype, "handleMouseDown", [action]);
    }
    handleFocusIn(event1) {
        event1.stopImmediatePropagation();
    }
    static {
        dt7948.n(this.prototype, "handleFocusIn", [action]);
    }
    handleKeyDown(event1) {
        if (this.args.selectKit.isExpanded) {
            if (event1.key === "Backspace") {
                if (this.args.selectKit.isFilterExpanded) {
                    this.args.selectKit.set("filter", this.args.selectKit.filter.slice(0, -1));
                    this.args.selectKit.triggerSearch();
                    this.args.selectKit.focusFilter();
                    event1.preventDefault();
                    event1.stopPropagation();
                }
            } else if (event1.key === "ArrowUp") {
                this.args.selectKit.highlightPrevious();
                event1.preventDefault();
            } else if (event1.key === "ArrowDown") {
                this.args.selectKit.highlightNext();
                event1.preventDefault();
            } else if (event1.key === "Enter") {
                event1.stopImmediatePropagation();
                this.args.selectKit.select(this.args.selectKit.highlighted.id, this.args.selectKit.highlighted);
                event1.preventDefault();
            } else if (event1.key === "Escape") {
                this.args.selectKit.close(event1);
                this.args.selectKit.headerElement().focus();
                event1.preventDefault();
                event1.stopPropagation();
            } else {
                if (this._isValidInput(event1.key)) {
                    this.args.selectKit.set("filter", event1.key);
                    this.args.selectKit.triggerSearch();
                    this.args.selectKit.focusFilter();
                    event1.preventDefault();
                    event1.stopPropagation();
                }
            }
        }
    }
    static {
        dt7948.n(this.prototype, "handleKeyDown", [action]);
    }
    _formatDescription(description1) {
        const limit1 = 200;
        return `${description1.slice(0, limit1)}${description1.length > limit1 ? "&hellip;" : ""}`;
    }
    _isValidInput(eventKey1) {
        // relying on passing the event to the input is risky as it could not work
        // dispatching the event won't work as the event won't be trusted
        // safest solution is to filter event and prefill filter with it
        const nonInputKeysRegex1 = /F\d+|Arrow.+|Meta|Alt|Control|Shift|Delete|Enter|Escape|Tab|Space|Insert|Backspace/;
        return !nonInputKeysRegex1.test(eventKey1);
    }
    static {
        setComponentTemplate(precompileTemplate("\n    {{!-- template-lint-disable no-pointer-down-event-binding --}}\n    <div class={{concatClass \"category-row\" \"select-kit-row\" (if this.isSelected \"is-selected\") (if this.isHighlighted \"is-highlighted\") (if this.isNone \"is-none\")}} role=\"menuitemradio\" data-index={{@index}} data-name={{this.rowName}} data-value={{this.rowValue}} data-title={{this.title}} title={{this.title}} data-guid={{this.guid}} {{on \"focusin\" this.handleFocusIn}} {{on \"mousedown\" this.handleMouseDown}} {{on \"mouseenter\" this.handleMouseEnter passive=true}} {{on \"click\" this.handleClick}} {{on \"keydown\" this.handleKeyDown}} aria-checked={{this.isSelected}} tabindex=\"0\">\n\n      {{#if this.category}}\n        <div class=\"category-status\" aria-hidden=\"true\">\n          {{#if this.hasParentCategory}}\n            {{#unless this.hideParentCategory}}\n              {{this.badgeForParentCategory}}\n            {{/unless}}\n          {{/if}}\n          {{this.badgeForCategory}}\n        </div>\n\n        {{#if this.shouldDisplayDescription}}\n          <div class=\"category-desc\" aria-hidden=\"true\">\n            {{dirSpan this.descriptionText htmlSafe=\"true\"}}\n          </div>\n        {{/if}}\n      {{else}}\n        {{htmlSafe this.label}}\n      {{/if}}\n    </div>\n  ", {
            strictMode: true,
            scope: () => ({
                concatClass,
                on,
                dirSpan,
                htmlSafe
            })
        }), this);
    }
}