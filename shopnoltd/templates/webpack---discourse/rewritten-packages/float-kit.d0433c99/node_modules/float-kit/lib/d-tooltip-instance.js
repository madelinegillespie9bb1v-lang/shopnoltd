import {
    tracked
} from "@glimmer/tracking";
import {
    action
} from "@ember/object";
import {
    guidFor
} from "@ember/object/internals";
import {
    setOwner
} from "@ember/owner";
import {
    service
} from "@ember/service";
import {
    TOOLTIP
} from "float-kit/lib/constants";
import FloatKitInstance from "float-kit/lib/float-kit-instance";
export default class DTooltipInstance extends FloatKitInstance {
    static {
        dt7948.g(this.prototype, "tooltip", [service]);
    }#
    tooltip = (dt7948.i(this, "tooltip"), void 0);
    static {
        dt7948.g(this.prototype, "expanded", [tracked], function() {
            return false;
        });
    }#
    expanded = (dt7948.i(this, "expanded"), void 0);
    /**
     * Indicates whether the tooltip is expanded or not.
     * @property {boolean} expanded - Tracks the state of tooltip expansion, initially set to false.
     */
    static {
        dt7948.g(this.prototype, "detachedTrigger", [tracked], function() {
            return false;
        });
    }#
    detachedTrigger = (dt7948.i(this, "detachedTrigger"), void 0);
    /**
     * Specifies whether the trigger for opening/closing the tooltip is detached from the tooltip itself.
     * This is the case when a tooltip is trigger programmatically instead of through the <DTooltip /> component.
     * @property {boolean} detachedTrigger - Tracks whether the trigger is detached, initially set to false.
     */
    static {
        dt7948.g(this.prototype, "options", [tracked]);
    }#
    options = (dt7948.i(this, "options"), void 0);
    /**
     * Configuration options for the DTooltipInstance.
     * @property {Object} options - Options object that configures the tooltip behavior and display.
     */
    static {
        dt7948.g(this.prototype, "_trigger", [tracked]);
    }#
    _trigger = (dt7948.i(this, "_trigger"), void 0);
    constructor(owner, options = {}) {
        super(...arguments);
        setOwner(this, owner);
        this.options = {
            ...TOOLTIP.options,
            ...options
        };
    }
    get trigger() {
        return this._trigger;
    }
    set trigger(element) {
        this._trigger = element;
        this.id = element.id || guidFor(element);
        this.setupListeners();
    }
    get portalOutletElement() {
        return document.getElementById("d-tooltip-portals");
    }
    async show() {
        await this.tooltip.show(this);
        await super.show(...arguments);
    }
    static {
        dt7948.n(this.prototype, "show", [action]);
    }
    async close() {
        await this.tooltip.close(this);
        await super.close(...arguments);
    }
    static {
        dt7948.n(this.prototype, "close", [action]);
    }
    async onMouseMove(event) {
        if (this.expanded && this.trigger.contains(event.target)) {
            return;
        }
        await this.onTrigger(event);
    }
    static {
        dt7948.n(this.prototype, "onMouseMove", [action]);
    }
    async onClick(event) {
        if (this.expanded && this.untriggers.includes("click")) {
            return await this.onUntrigger(event);
        }
        await this.onTrigger(event);
    }
    static {
        dt7948.n(this.prototype, "onClick", [action]);
    }
    async onMouseLeave(event) {
        if (this.untriggers.includes("hover")) {
            await this.onUntrigger(event);
        }
    }
    static {
        dt7948.n(this.prototype, "onMouseLeave", [action]);
    }
    async onTrigger() {
        await this.options.beforeTrigger ? .(this);
        await this.show();
    }
    static {
        dt7948.n(this.prototype, "onTrigger", [action]);
    }
    async onUntrigger() {
        await this.close();
    }
    static {
        dt7948.n(this.prototype, "onUntrigger", [action]);
    }
    destroy() {
        this.close();
        this.tearDownListeners();
    }
    static {
        dt7948.n(this.prototype, "destroy", [action]);
    }
}